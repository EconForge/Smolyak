"""
This file contains a class that builds a Smolyak Grid.  The hope is that
it will eventually contain the interpolation routines necessary so that
the given some data, this class can build a grid and use the Chebyshev
polynomials to interpolate and approximate the data.

Method based on Judd, Maliar, Maliar, Valero 2013 (W.P)

Author: Chase Coleman
"""

import numpy as np
import numpy.linalg as la
from numpy.polynomial import chebyshev
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from sklearn.utils.extmath import cartesian
import time as time
from numba import int_, double
from numba.decorators import jit, autojit

@jit(argtypes=[int_])
def _find_S_n(n):
    """
    This method finds the element S_n for the Chebyshev Extrema
    """

    if n==1:
        return np.array([0])

    # Apply the necessary transformation to get the nested sequence
    m_i = 2**(n-1) + 1

    # Create an array of values that will be passed in to calculate
    # the set of values
    comp_vals = np.arange(1., m_i + 1.)

    # Values are - cos(pi(j-1)/(n-1)) for j in [1, 2, ..., n]
    vals = -1. * np.cos(np.pi*(comp_vals - 1.)/(m_i-1.))
    # vals[np.where(np.abs(vals) < 1e-14)] = 0.0

    return vals


@jit(argtypes=[int_])
def _find_A_n(n):
    """
    This method finds all of the unidimensional disjoint sets
    that we will use to construct the grid.  It improves on
    past algorithms by noting that A_{n} = S_{n}[evens] except for
    A_1 = {0} and A_2 = {-1, 1}. Additionally, A_{n} = A_{n+1}[odds]
    This prevents the calculation of these nodes repeatedly.  Thus
    we only need to calculate biggest of the S_n's to build the
    sequence of A_n's
    """

    # # Start w finding the biggest Sn(We will subsequently reduce it)
    Sn = _find_S_n(n)
    A_chain = []

    # Need a for loop to extract remaining elements
    for seq in xrange(2, n):
        num = Sn.size
        # Need odd indices in python because indexing starts at 0
        A_chain.append(Sn[range(1, num, 2)])
        Sn = Sn[range(0, num, 2)]

    A_chain.append(np.array([-1, 1]))
    A_chain.append(np.array([0]))
    A_chain.reverse()

    return A_chain


@jit(argtypes=[int_, int_])
def build_sparse_grid(d, mu):
    """
    This method builds a grid for the object
    """

    # Need to capture up to value mu + 1 so in python need mu+2
    possible_values = np.arange(1, mu + 2)
    p_vals = np.tile(possible_values, ())

    prod_vals = cartesian(p_vals, out=None)


    An = _find_A_n(d + mu)
    points = []
    # inds = []

    for el in prod_vals:
        if d <= el.sum <= d + mu:
            temp = [An[i-1] for i in el]
            # Save these indices that we iterate through gecause
            # we need them for the chebyshev polynomial combination
            # inds.append(el)
            points.append(np.array(list(cartesian(*temp, out=None))))

    grid = np.vstack(points)

    return grid

