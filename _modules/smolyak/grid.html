


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>smolyak.grid &mdash; Smolyak 0.0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../../',
        VERSION:'0.0.1',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="Smolyak 0.0.1 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../index.html" class="icon icon-home"> Smolyak</a>
        <form class="wy-form" action="../../search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../math.html">Mathematical Background</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#smolyak-grid">Smolyak Grid</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../math.html#smolyak-basis-polynomials">Smolyak Basis Polynomials</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/modules.html">smolyak</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../apidoc/smolyak.html">smolyak Package</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">Smolyak</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="../../index.html">Docs</a> &raquo;</li>
  <li><a href="">smolyak.grid</a></li>
  
</ul>
<hr/>

          
  <h1>Source code for smolyak.grid</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file contains a class that builds a Smolyak Grid.  The hope is that</span>
<span class="sd">it will eventually contain the interpolation routines necessary so that</span>
<span class="sd">the given some data, this class can build a grid and use the Chebyshev</span>
<span class="sd">polynomials to interpolate and approximate the data.</span>

<span class="sd">Method based on Judd, Maliar, Maliar, Valero 2013 (W.P)</span>

<span class="sd">Authors: Chase Coleman and Spencer Lyon</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">combinations_with_replacement</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lu</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">util</span> <span class="kn">import</span> <span class="o">*</span>


<div class="viewcode-block" id="a_chain"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.a_chain">[docs]</a><span class="k">def</span> <span class="nf">a_chain</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method finds all of the unidimensional disjoint sets</span>
<span class="sd">    that we will use to construct the grid.  It improves on</span>
<span class="sd">    past algorithms by noting that A_{n} = S_{n}[evens] except for</span>
<span class="sd">    A_1 = {0} and A_2 = {-1, 1}. Additionally, A_{n} = A_{n+1}[odds]</span>
<span class="sd">    This prevents the calculation of these nodes repeatedly.  Thus</span>
<span class="sd">    we only need to calculate biggest of the S_n&#39;s to build the</span>
<span class="sd">    sequence of A_n&#39;s</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : scalar : integer</span>
<span class="sd">      This is the number of disjoint sets from Sn that this should make</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A_chain : dictionary : lists</span>
<span class="sd">      This is a dictionary of the disjoint sets that are made.  They are</span>
<span class="sd">      indexed by the integer corresponding</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># # Start w finding the biggest Sn(We will subsequently reduce it)</span>
    <span class="n">Sn</span> <span class="o">=</span> <span class="n">_s_n</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">A_chain</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">A_chain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span>
    <span class="n">A_chain</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span>

    <span class="c"># Need a for loop to extract remaining elements</span>
    <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">Sn</span><span class="o">.</span><span class="n">size</span>
        <span class="c"># Need odd indices in python because indexing starts at 0</span>
        <span class="n">A_chain</span><span class="p">[</span><span class="n">seq</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Sn</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
        <span class="c"># A_chain.append(list(Sn[range(1, num, 2)]))</span>
        <span class="n">Sn</span> <span class="o">=</span> <span class="n">Sn</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">A_chain</span>
</div>
<span class="k">def</span> <span class="nf">_s_n</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method finds the element S_n for the Chebyshev Extrema</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>

    <span class="c"># Apply the necessary transformation to get the nested sequence</span>
    <span class="n">m_i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c"># Create an array of values that will be passed in to calculate</span>
    <span class="c"># the set of values</span>
    <span class="n">comp_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">m_i</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>

    <span class="c"># Values are - cos(pi(j-1)/(n-1)) for j in [1, 2, ..., n]</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">comp_vals</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">m_i</span><span class="o">-</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">vals</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-14</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="n">vals</span>

<div class="viewcode-block" id="smol_inds"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.smol_inds">[docs]</a><span class="k">def</span> <span class="nf">smol_inds</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method finds all of the indices that satisfy the requirement</span>
<span class="sd">    that d \leq \sum_{i=1}^d \leq d + \mu.  Once we have these, then</span>
<span class="sd">    they can be used to build both the grid and the polynomial</span>
<span class="sd">    basis.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>
<span class="sd">    This method sets the attribute smol_inds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Need to capture up to value mu + 1 so in python need mu+2</span>
    <span class="n">possible_values</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mu</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c"># find all (i1, i2, ... id) such that their sum is in range</span>
    <span class="c"># we want; this will cut down on later iterations</span>
    <span class="n">poss_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">combinations_with_replacement</span><span class="p">(</span><span class="n">possible_values</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                  <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="o">+</span><span class="n">mu</span><span class="p">]</span>

    <span class="n">true_inds</span> <span class="o">=</span> <span class="p">[[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">permute</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">val</span><span class="p">))]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">poss_inds</span><span class="p">]</span>

    <span class="c"># Add the d dimension 1 array so that we don&#39;t repeat it a bunch</span>
    <span class="c"># of times</span>
    <span class="n">true_inds</span><span class="o">.</span><span class="n">extend</span><span class="p">([[[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">]])</span>

    <span class="n">tinds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">true_inds</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">tinds</span>
</div>
<div class="viewcode-block" id="build_grid"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.build_grid">[docs]</a><span class="k">def</span> <span class="nf">build_grid</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method builds a grid for the object</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>
<span class="sd">    This method sets the attribute grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Get An chain</span>
    <span class="n">An</span> <span class="o">=</span> <span class="n">a_chain</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Need to get the correct indices</span>

    <span class="n">tinds</span> <span class="o">=</span> <span class="n">smol_inds</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">tinds</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">An</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">el</span><span class="p">]</span>
        <span class="c"># Save these indices that we iterate through because</span>
        <span class="c"># we need them for the chebyshev polynomial combination</span>
        <span class="c"># inds.append(el)</span>
        <span class="n">points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">temp</span><span class="p">)))</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">to_object_array_tuples</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">grid</span>
</div>
<div class="viewcode-block" id="phi_chain"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.phi_chain">[docs]</a><span class="k">def</span> <span class="nf">phi_chain</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the disjoint sets of aphi&#39;s that will be used to compute</span>
<span class="sd">    which functions we need to calculate</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># First create a dictionary</span>
    <span class="n">aphi_chain</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">aphi_chain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">aphi_chain</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

    <span class="n">curr_val</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">end_val</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">curr_val</span><span class="p">,</span> <span class="n">end_val</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">aphi_chain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
        <span class="n">curr_val</span> <span class="o">=</span> <span class="n">end_val</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">aphi_chain</span>
</div>
<div class="viewcode-block" id="poly_inds"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.poly_inds">[docs]</a><span class="k">def</span> <span class="nf">poly_inds</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function builds the indices of the basis polynomials that</span>
<span class="sd">    will be used to interpolate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">smol_inds</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">aphi</span> <span class="o">=</span> <span class="n">phi_chain</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Bring in polynomials</span>
    <span class="c"># cheb_dict = self.calc_chebvals()</span>

    <span class="n">base_polys</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">aphi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">el</span><span class="p">]</span>
        <span class="c"># Save these indices that we iterate through because</span>
        <span class="c"># we need them for the chebyshev polynomial combination</span>
        <span class="c"># inds.append(el)</span>
        <span class="n">base_polys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">temp</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">base_polys</span>
</div>
<div class="viewcode-block" id="build_B"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.build_B">[docs]</a><span class="k">def</span> <span class="nf">build_B</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function builds the matrix B that will be used to calc</span>
<span class="sd">    the interpolation coefficients for a given set of data.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>
<span class="sd">    This method sets the attributes B, B_L, B_U</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ts</span> <span class="o">=</span> <span class="n">cheby2n</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">m_i</span><span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">base_polys</span> <span class="o">=</span> <span class="n">poly_inds</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;F&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">comb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">base_polys</span><span class="p">):</span>
        <span class="n">B</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="p">[</span><span class="n">Ts</span><span class="p">[</span><span class="n">comb</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">B</span>
</div>
<div class="viewcode-block" id="cheby_eval"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.cheby_eval">[docs]</a><span class="k">def</span> <span class="nf">cheby_eval</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">past_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">curr_val</span> <span class="o">=</span> <span class="n">x</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">past_val</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">curr_val</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">curr_val</span> <span class="o">-</span> <span class="n">past_val</span>
        <span class="n">past_val</span> <span class="o">=</span> <span class="n">curr_val</span>
        <span class="n">curr_val</span> <span class="o">=</span> <span class="n">temp</span>

    <span class="k">return</span> <span class="n">curr_val</span>
</div>
<div class="viewcode-block" id="cheby2n"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.cheby2n">[docs]</a><span class="k">def</span> <span class="nf">cheby2n</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="c"># computes the chebychev polynomials of the first kind</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">dim</span><span class="p">)</span>
    <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
    <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">results</span>

</div>
<div class="viewcode-block" id="num_grid_points"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.num_grid_points">[docs]</a><span class="k">def</span> <span class="nf">num_grid_points</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mu</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">mu</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>

    <span class="k">if</span> <span class="n">mu</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">d</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">6.</span>
</div>
<div class="viewcode-block" id="m_i"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.m_i">[docs]</a><span class="k">def</span> <span class="nf">m_i</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;i must be positive&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

</div>
<div class="viewcode-block" id="SmolyakGrid"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.SmolyakGrid">[docs]</a><span class="k">class</span> <span class="nc">SmolyakGrid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class currently takes a dimension and a degree of polynomial</span>
<span class="sd">    and builds the Smolyak Sparse grid.  We base this on the work by</span>
<span class="sd">    Judd Maliar Maliar and Valero.  Hope to obtain speed ups beyond</span>
<span class="sd">    what they achieved.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : scalar : integer</span>
<span class="sd">        This is the dimension of grid that you are building</span>

<span class="sd">    mu : scalar : integer</span>
<span class="sd">        mu is a parameter that defines the fineness of grid that we</span>
<span class="sd">        want to build</span>

<span class="sd">    do : str, optional(default=&#39;all&#39;)</span>
<span class="sd">        do specifies whether you just want to build the grid or</span>
<span class="sd">        whether it should build the whole object.  Only takes values</span>
<span class="sd">        of &quot;all&quot; or &quot;grid&quot;.  Default is &quot;all&quot;</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    d : scalar : integer</span>
<span class="sd">        This is the dimension of grid that you are building</span>

<span class="sd">    mu : scalar : integer</span>
<span class="sd">        mu is a parameter that defines the fineness of grid that we</span>
<span class="sd">        want to build</span>

<span class="sd">    grid : array, float, ndim=2</span>
<span class="sd">        This is the sparse grid that we need to build</span>

<span class="sd">    inds : list : list</span>
<span class="sd">        This is a lists of lists that contains all of the indices</span>

<span class="sd">    B : np.ndarray : floats</span>
<span class="sd">        This is the B matrix that is used to do lagrange interpolation</span>

<span class="sd">    B_L : np.ndarray : floats</span>
<span class="sd">        Lower triangle matrix of the decomposition of B</span>

<span class="sd">    B_U : np.ndarray : floats</span>
<span class="sd">        Upper triangle matrix of the decomposition of B</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    s = SmolyakGrid(3, 2)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">do</span><span class="o">=</span><span class="s">&quot;all&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The parameter mu needs to be &gt; 1.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;You are trying to build a one dimensional</span><span class="se">\</span>
<span class="s">                             grid.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">build_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inds</span> <span class="o">=</span> <span class="n">smol_inds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do</span> <span class="o">==</span> <span class="s">&quot;all&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">build_B</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
            <span class="c"># Compute LU decomposition</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">lu</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>  <span class="c"># pass permute_l as true. See scipy docs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B_L</span> <span class="o">=</span> <span class="n">l</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">B_U</span> <span class="o">=</span> <span class="n">u</span>



    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Smolyak Grid:</span><span class="se">\n\t</span><span class="s">d: {0} </span><span class="se">\n\t</span><span class="s">mu: {1} </span><span class="se">\n\t</span><span class="s">npoints: {2}&quot;</span>
        <span class="k">return</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__repr__</span><span class="p">)</span>

<div class="viewcode-block" id="SmolyakGrid.plot_grid"><a class="viewcode-back" href="../../apidoc/smolyak.html#smolyak.grid.SmolyakGrid.plot_grid">[docs]</a>    <span class="k">def</span> <span class="nf">plot_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a simple function that beautifully plots the grid for</span>
<span class="sd">        the 2 and 3d cases</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;0.75&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s">&#39;3d&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">&#39;0.75&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Can only plot 2 or 3 dimensional problems&#39;</span><span class="p">)</span></div></div>
</pre></div>

          <footer>
  

  <hr/>

  <p>
      &copy; Copyright 2013, EconForge.
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>